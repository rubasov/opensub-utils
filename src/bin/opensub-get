#! /usr/bin/python

__doc__ = """
Usage:
    opensub-get (-h | --help)
    opensub-get (-m | --man)
    opensub-get (-V | --version)
    opensub-get [-v | -vv]
                [-f | --force]
                [-l <language> | --language=<language>]
                [-s <server> | --server=<server>]
                [--extract | --template=<template>]
                <video-files>...

Options:
    -h, --help     Print usage and exit.
    -m, --man      Print full manual and exit.
    -V, --version  Print version and exit.

    -v, --verbose  Increase verbosity. May be used twice (-vv).
    -f, --force    Overwrite existing files when creating output files.

    -l <language>, --language=<language>
        ISO 639 code of subtitle language. [default: eng]

    -s <server>, --server=<server>
        Subtitle server. [default: www.opensubtitles.org]

    -x, --extract
        Extract output files as they are.
        Mutually exclusive with --template.
        See NAMING SCHEMES in manual (--man).

    -t <template>, --template=<template>
        Name output files according to template.
        Mutually exclusive with --extract.
        See NAMING SCHEMES in manual (--man).
        [default: {video/dir}{video/base}{subtitle/ext}]
"""

__doc_rest__ = """
Description:
    opensub-get - Download subtitles for a movie from opensubtitles.org.

    Do you hunt for subtitles based on movie title, file name, file size,
    frame rate? Do you still adjust the subtitle delay and frame rate
    in case you didn't find the perfect subtitle file? Are you tired of
    all this?

    This program calculates a hash of the movie you give it, and queries
    opensubtitles.org by hash. The hash is a function of file size and
    _content_. Therefore you're guaranteed to get the subtitle that is a
    perfect match. Its quality may be high or low, but someone uploaded
    it for the _exact_ same video file you have.

    After downloading the subtitle zip archive, extract the files in a
    convenient way without overwriting any existing files (unless you
    explicitly ask for it). For details see Naming Schemes.

Subtitle File Naming Schemes:
    1) Default: to match video file names.

        This mode assembles the output file name from:

        * the video file path minus its extension
        * the subtitle extension as in the archive

        Example:

        arguments      output files
        --             --
        movie_cd1.avi  movie_cd1.srt (or .sub, .smi, whatever)
        movie_cd2.avi  movie_cd2.srt
        ...

        Internally uses template: {video/dir}{video/base}{subtitle/ext}

    2) Extract the archive as it is: --extract.

        Keep the subtitle file names as they are in the archive,
        but throw away the leading directories if there's any.

        Internally uses template: {subtitle/base}{subtitle/ext}

    3) Use a template explicitly: --template TEMPLATE

        The following variables in TEMPLATE will be substituted:

        {num}
        Running index of subtitle files. Doesn't make much sense unless
        you have multiple subtitle files. Starts counting from 1.

        {video/dir} {video/base} {video/ext}
        Parts of the respective video file path.

        {subtitle/dir} {subtitle/base} {subtitle/ext}
        Parts of the respective subtitle file path as it is in the archive.

        Path parts example:

            video        : path/to/file.foo

            {video/dir}  : path/to/
            {video/base} : file
            {video/ext}  : .foo

        The concatenation of dir, base and ext add up to a path
        equivalent to the original.

        '--template -' writes the concatenated output to stdout.

Environment Variables:
    http_proxy=proxy:port - For details see Python's urrlib2.

Known Limitations:
    Multiple video file arguments are interpreted as video files belonging
    to the same movie. Such movies were typical in the Compact Disc era.
    They are still encountered - especially amongst older and rarer
    movies.  This program still supports them, but this support comes at
    the price of less convenient handling of multiple movies or episodes.
    Suggested workarounds for multiple one-video-file movies or for
    episodes of series:

        for episode in *
        do
            opensub-get "$episode"
        done

        find . -iname '*.avi' -print0 | xargs -0 -n1 opensub-get

See Also:
    opensub-hash

    Search by movie title and other search options:
        http://www.opensubtitles.org/search/

    Subtitle upload:
        http://www.opensubtitles.org/upload/

Credits:
    Many thanks to opensubtitles.org's folks for their great service.
    Copyright (c) 2013 Bence Romsics <rubasov@gmail.com>
"""

# FIXME better version handling (use git describe)
__version__ = "0.99"

import logging
import os
import sys
import textwrap

import six
if six.PY3:
    import urllib.request as urllib_request
else:
    import urllib2 as urllib_request

import docopt

sys.path.append(
    os.path.join(
        os.path.dirname(
            os.path.realpath(
                __file__)),
        "..",
        "lib"))

import opensub
import util


def parse_args(doc=__doc__, version=__version__, argv=sys.argv[1:]):

    """
    Parse command line options and arguments.

    Also handles early exits, like print-help-and-exit.

    Returns:
        dict of options and arguments
    """

    args = docopt.docopt(doc, version=version, argv=argv)

    if args["--man"]:
        print(__doc__, __doc_rest__)
        sys.exit(0)

    # make '--extract' a synonim to '--template {subtitle/base}{subtitle/ext}'
    if args["--extract"]:
        args["--template"] = "{subtitle/base}{subtitle/ext}"

    for video_file in args["<video-files>"]:
        if not os.path.isfile(video_file):
            sys.stdout.flush()
            sys.stderr.write("no such file: {}\n".format(video_file))
            sys.exit(1)

    return args


def main():

    args = parse_args()
    util.setup_logging(verbosity=args["--verbose"])

    opener = util.default_opener(version=__version__)

    ua = opensub.UserAgent(
        server=args["--server"],
        opener=opener,
        )

    search_results = ua.search(
        movie=args["<video-files>"],
        language=args["--language"],
        )

    try:
        preferred_result = search_results[0]
    except IndexError:
        logging.error("subtitle not found")
        sys.stdout.flush()
        util.print_not_found_hint(sys.stderr)
        sys.exit(1)

    with opensub.SubtitleArchive(
        url=preferred_result, opener=opener) as archive:

        util.extract_archive(
            archive=archive,
            movie=args["<video-files>"],
            builder=util.FilenameBuilder(args["--template"]),
            overwrite=args["--force"],
            )


if __name__ == "__main__":
    main()
