#! /usr/bin/python

__doc__ = """
Usage:
    opensub-get (-h | --help)
    opensub-get (-m | --man)
    opensub-get (-V | --version)
    opensub-get [-v | -vv]
                [-f | --force]
                [-l <language> | --language=<language>]
                [-s <server> | --server=<server>]
                [--extract | --template=<template>]
                <video-files>...

Options:
    -h, --help     Print usage and exit.
    -m, --man      Print full manual and exit.
    -V, --version  Print version and exit.

    -v, --verbose  Increase verbosity. May be used twice (-vv).
    -f, --force    Overwrite existing files when creating output files.

    -l <language>, --language=<language>
        ISO 639 code of subtitle language. [default: eng]

    -s <server>, --server=<server>
        Subtitle server. [default: www.opensubtitles.org]

    -x, --extract
        Extract output files as they are.
        Mutually exclusive with --template.
        See NAMING SCHEMES in manual (--man).

    -t <template>, --template=<template>
        Name output files according to template.
        Mutually exclusive with --extract.
        See NAMING SCHEMES in manual (--man).
"""

__doc_rest__ = """
Description:
    opensub-get - Download subtitles for a movie from opensubtitles.org.

    Do you hunt for subtitles based on movie title, file name, file size,
    frame rate? Do you still adjust the subtitle delay and frame rate
    in case you didn't find the perfect subtitle file? Are you tired of
    all this?

    This program calculates a hash of the movie you give it, and queries
    opensubtitles.org by hash. The hash is a function of file size and
    _content_. Therefore you're guaranteed to get the subtitle that is a
    perfect match. Its quality may be high or low, but someone uploaded
    it for the _exact_ same video file you have.

    After downloading the subtitle zip archive, extract the files in a
    convenient way without overwriting any existing files (unless you
    explicitly ask for it). For details see Naming Schemes.

Subtitle File Naming Schemes:
    1) Default: to match video file names.

        This mode assembles the output file name from:

        * the video file name minus its extension
        * the subtitle extension as in the archive

        Example:

        arguments      output files
        --             --
        movie_cd1.avi  movie_cd1.srt (or .sub, .smi, whatever)
        movie_cd2.avi  movie_cd2.srt
        ...

    2) Use a template: --template 'foo-{num}.{ext}'.

        {num} Will be substituted by a running index of subtitle files.
              Doesn't make much sense unless you have multiple subtitle
              files. Starts counting from 1.

        {ext} Will be substituted by the subtitle extension
              as it was in the archive.

        '--template /dev/stdout --force'
            writes the concatenated output to stdout.

    3) Extract the archive as it is: --extract.

        Keep the subtitle file names as they are in the archive,
        but chop the leading directories if there's any.

Environment Variables:
    http_proxy=proxy:port - For details see Python's urrlib2.

Known Limitations:
    Can't handle more than one movie at a time (or episodes of a series).
    Suggested workarounds:

        for movie in *
        do
            opensub-get "$movie"
        done

        find . -iname '*.avi' -print0 | xargs -0 -n1 opensub-get

See Also:
    Search by movie title and other search options:
        http://www.opensubtitles.org/search/

    Subtitle upload:
        http://www.opensubtitles.org/upload/

License:
    FIXME choose license

Credits:
    Many thanks to opensubtitles.org's folks for their great service.
    Copyright 2013 Bence Romsics <rubasov@gmail.com>
"""

__TODO__ = """
functional
    select 2nd, 3rd, etc. search result
    parameters
        --template -
            --template /dev/stdout --force
        --template {base}.{ext}
        --language lang1,lang2,...
            preference order
            validate language id
    proper exit value
    upload to github
        ask for review by opensubtitles folks
    license
development practice
    python2/3 compatibility
    setup.py
"""

__version__ = "0.99"

import errno
import logging
import os
import sys
import urllib2

sys.path.append(
    os.path.join(
        os.path.dirname(
            os.path.realpath(
                __file__)),
        "..",
        "lib"))

import docopt

import opensubtitles


def store(content, path, overwrite=False, suppress_eexist=True):

    """
    Write content to file at path.

    Takes:
        content - content to be written
        path - path to open and write to
        overwrite - allow/disallow to overwrite existing files (boolean)
        suppress_eexist - turn overwrite exception into a warning (boolean)
    """

    logging.info("store: {}".format(path))

    if overwrite:

        with open(path, "w") as fo:
            fo.write(content)

    else:

        try:
            # Open the file only if the open actually creates it,
            # that is do not overwrite an existing file.
            # FIXME unix only
            fd = os.open(
                path, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
        except OSError as e:
            if e.errno == errno.EEXIST:
                if suppress_eexist:
                    logging.warning(
                        "refusing to overwrite file: {}".format(path))
                    pass
                else:
                    raise
            else:
                raise
        else:
            with os.fdopen(fd, "w") as fo:
                fo.write(content)

    return None


def write_subtitle_files(args, subtitle_list):

    """Procedure to write output files according to naming scheme."""

    def ext_no_dot(path):

        """Extension without leading dot."""

        ext = os.path.splitext(path)[1]
        if ext[1:] == "":
            raise Exception("path has no extension: {}".format(path))
        return ext[1:]

    # naming scheme: use a template
    if args["--template"] is not None:

        # maybe FIXME option to override start=1
        for idx, subtitle in enumerate(subtitle_list, start=1):
            ext = ext_no_dot(subtitle.name)
            dst = args["--template"].format(num=idx, ext=ext)
            store(
                content=subtitle.content,
                path=dst,
                overwrite=args["--force"])

    # naming scheme: extract archive
    elif args["--extract"]:

        for subtitle in subtitle_list:
            dst = os.path.basename(subtitle.name)
            store(
                content=subtitle.content,
                path=dst,
                overwrite=args["--force"])

    # naming scheme: match video file names
    else:

        # FIXME unchecked assumption
        # The user provided video files in "natural order".

        for video_file, subtitle in zip(args["<video-files>"], subtitle_list):
            base = os.path.splitext(video_file)[0]
            ext = ext_no_dot(subtitle.name)
            dst = "{}.{}".format(base, ext)
            store(
                content=subtitle.content,
                path=dst,
                overwrite=args["--force"])

    return None


def parse_args():

    """
    Procedure to parse command line options and arguments
    and to handle early exits.
    """

    args = docopt.docopt(__doc__, version=__version__)

    if args["--man"]:
        print __doc__, __doc_rest__
        sys.exit(0)

    for video_file in args["<video-files>"]:
        if not os.path.isfile(video_file):
            raise Exception("no such file: {}".format(video_file))

    return args


def setup_logging(verbosity):

    """Procedure to set log level and format."""

    log_level_dict = {
        0: "WARNING",
        1: "INFO",
        2: "DEBUG",
        }

    try:
        log_level = getattr(logging, log_level_dict[verbosity])
    except KeyError:
        raise Exception(
            "invalid log level: -{}".format("v" * verbosity))

    logging.basicConfig(
        level=log_level,
        format="%(levelname)s: %(filename)s:%(lineno)d: %(message)s",
        )

    return None


def main():

    args = parse_args()
    setup_logging(verbosity=args["--verbose"])

    user_agent = "{}/{}".format(
        os.path.basename(sys.argv[0]), __version__)

    headers = list()
    headers.append(("User-Agent", user_agent))

    # This is a hack for less intrusive testing. Do not rely on it ever.
    # $ magic=more http_proxy=127.0.0.1:8123 program ...
    if "magic" in os.environ:
        logging.warning("env(magic) present, anything may happen")
        headers.append(("Cache-Control", "only-if-cached"))

    opener = urllib2.build_opener()
    opener.addheaders = headers

    ua = opensubtitles.UserAgent(
        server=args["--server"],
        opener=opener,
        )

    subtitle_list = ua.get_subtitle(
        movie=args["<video-files>"],
        language=args["--language"],
        )

    write_subtitle_files(
        args=args,
        subtitle_list=subtitle_list,
        )

if __name__ == "__main__":
    main()
