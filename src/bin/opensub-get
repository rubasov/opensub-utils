#! /usr/bin/python

__doc__ = """
Usage:
    opensub-get (-h | --help)
    opensub-get (-m | --man)
    opensub-get (-V | --version)
    opensub-get [-v | -vv]
                [-f | --force]
                [-l <language> | --language=<language>]
                [-s <server> | --server=<server>]
                [--extract | --template=<template>]
                <video-files>...

Options:
    -h, --help     Print usage and exit.
    -m, --man      Print full manual and exit.
    -V, --version  Print version and exit.

    -v, --verbose  Increase verbosity. May be used twice (-vv).
    -f, --force    Overwrite existing files when creating output files.

    -l <language>, --language=<language>
        ISO 639 code of subtitle language. [default: eng]

    -s <server>, --server=<server>
        Subtitle server. [default: www.opensubtitles.org]

    -x, --extract
        Extract output files as they are.
        Mutually exclusive with --template.
        See NAMING SCHEMES in manual (--man).

    -t <template>, --template=<template>
        Name output files according to template.
        Mutually exclusive with --extract.
        See NAMING SCHEMES in manual (--man).
        [default: {base}.{ext}]
"""

__doc_rest__ = """
Description:
    opensub-get - Download subtitles for a movie from opensubtitles.org.

    Do you hunt for subtitles based on movie title, file name, file size,
    frame rate? Do you still adjust the subtitle delay and frame rate
    in case you didn't find the perfect subtitle file? Are you tired of
    all this?

    This program calculates a hash of the movie you give it, and queries
    opensubtitles.org by hash. The hash is a function of file size and
    _content_. Therefore you're guaranteed to get the subtitle that is a
    perfect match. Its quality may be high or low, but someone uploaded
    it for the _exact_ same video file you have.

    After downloading the subtitle zip archive, extract the files in a
    convenient way without overwriting any existing files (unless you
    explicitly ask for it). For details see Naming Schemes.

Subtitle File Naming Schemes:
    1) Default: to match video file names.

        This mode assembles the output file name from:

        * the video file name minus its extension
        * the subtitle extension as in the archive

        Example:

        arguments      output files
        --             --
        movie_cd1.avi  movie_cd1.srt (or .sub, .smi, whatever)
        movie_cd2.avi  movie_cd2.srt
        ...

    2) Use a template: --template 'foo-{num}.{ext}'.

        {num} Will be substituted by a running index of subtitle files.
              Doesn't make much sense unless you have multiple subtitle
              files. Starts counting from 1.

        {ext} Will be substituted by the subtitle extension
              as it was in the archive.

        '--template -' writes the concatenated output to stdout.

    3) Extract the archive as it is: --extract.

        Keep the subtitle file names as they are in the archive,
        but chop the leading directories if there's any.

Environment Variables:
    http_proxy=proxy:port - For details see Python's urrlib2.

Known Limitations:
    Multiple video file arguments are interpreted as video files belonging
    to the same movie. Such movies were typical in the Compact Disc era.
    They are still encountered - especially amongst older and rarer
    movies.  This program still supports them, but this support comes at
    the price of less convenient handling of multiple movies or episodes.
    Suggested workarounds for multiple one-video-file movies or for
    episodes of series:

        for episode in *
        do
            opensub-get "$episode"
        done

        find . -iname '*.avi' -print0 | xargs -0 -n1 opensub-get

See Also:
    opensub-hash

    Search by movie title and other search options:
        http://www.opensubtitles.org/search/

    Subtitle upload:
        http://www.opensubtitles.org/upload/

Credits:
    Many thanks to opensubtitles.org's folks for their great service.
    Copyright (c) 2013 Bence Romsics <rubasov@gmail.com>
"""

# FIXME better version handling (use git describe)
__version__ = "0.99"

import errno
import logging
import os
import shutil
import sys
import textwrap

import six
if six.PY3:
    import urllib.request as urllib_request
else:
    import urllib2 as urllib_request

import docopt

sys.path.append(
    os.path.join(
        os.path.dirname(
            os.path.realpath(
                __file__)),
        "..",
        "lib"))

import opensub
import util


def parse_args(doc=__doc__, version=__version__, argv=sys.argv[1:]):

    """
    Parse command line options and arguments.

    Also handles early exits, like print-help-and-exit.

    Returns:
        dict of options and arguments
    """

    args = docopt.docopt(doc, version=version, argv=argv)

    if args["--man"]:
        print(__doc__, __doc_rest__)
        sys.exit(0)

    for video_file in args["<video-files>"]:
        if not os.path.isfile(video_file):
            raise Exception("no such file: {}".format(video_file))

    return args


def print_not_found_hint(file):

    msg = textwrap.dedent(
        """
        Maybe...
        ...the video has embedded subtitles?
               Typical for .mkv files.
        ...you could try a different --language?
        ...you could try other search options?
               By title, IMDb id, etc.
               http://www.opensubtitles.org/search/
        ...you could upload the subtitle later
               so that others have better luck.
               http://www.opensubtitles.org/upload/
        """
        )
    file.write(msg)


def main():

    args = parse_args()
    util.setup_logging(verbosity=args["--verbose"])

    opener = util.default_opener(version=__version__)

    ua = opensub.UserAgent(
        server=args["--server"],
        opener=opener,
        )

    search_results = ua.search(
        movie=args["<video-files>"],
        language=args["--language"],
        )

    try:
        preferred_result = search_results[0]
    except IndexError:
        logging.error("subtitle not found")
        sys.stdout.flush()
        print_not_found_hint(sys.stderr)
        sys.exit(1)

    if args["--extract"]:
        # naming scheme: extract archive
        builder = util.ExtractBuilder()
    else:
        # naming scheme: use a template
        builder = util.TemplateBuilder(template=args["--template"])

    with opensub.SubtitleArchive(
        url=preferred_result, opener=opener) as archive:

        for (subtitle_file, archived_name), video_path \
            in zip(archive.open_subtitle_files(), args["<video-files>"]):

            dst = builder.build(
                archived_name=archived_name,
                video_path=video_path,
                )

            logging.debug("src: {}".format(archived_name))
            logging.debug("dst: {}".format(dst))

            try:
                dst_file = util.safe_open(dst, overwrite=args["--force"])
            except OSError as e:
                if e.errno == errno.EEXIST:
                    logging.warning(
                        "refusing to overwrite file: {}".format(dst))
                else:
                    raise
            else:
                shutil.copyfileobj(subtitle_file, dst_file)

                if dst_file != sys.stdout:
                    dst_file.close()

    # FIXME warn if we didn't write a subtitle for all input files


if __name__ == "__main__":
    main()
