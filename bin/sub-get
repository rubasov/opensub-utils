#! /usr/bin/python

"""
NAME
    sub-get - download subtitle for a movie from opensubtitles.org

SYNOPSIS
    sub-get [-h] [-v|-vv] [-l lang] [...] MOVIE-FILE [MOVIE-FILE-CD2 ...]

DESCRIPTION
    Using the hash of video files query opensubtitles.org.
    Download a subtitle archive and extract the subtitles.

SUBTITLE FILE NAMING SCHEMES
    1) Default: to match video file names.

        This mode assembles the output file name from:

        * the input file name minus its extension
        * the subtitle extensions from the archive

        Example:

        arguments      output files
        --             --
        movie_cd1.avi  movie_cd1.srt (or .sub, .ass, whatever)
        movie_cd2.avi  movie_cd2.srt
        ...

    2) Use a template: --template 'foo-{num}.{ext}'.

        {num} Will be substituted by a running index of subtitle files.
              Doesn't make much sense unless you have multiple subtitle files.
              Starts counting from 1.

        {ext} Will be substituted by the subtitle extension
              as it was in the archive.

        '--template /dev/stdout' writes the concatenated output to stdout.

    3) Extract the archive as it is: --extract.

        Keep the subtitle file names as they are in the archive, but chop
        the leading directories if there's any.

OPTIONS
    FIXME
    -l --language
    -s --server
    -t --template
    -v --verbose
    -x --extract

ENVIRONMENT VARIABLES
    http_proxy FIXME

LICENSE
    FIXME

CREDITS
    Many thanks to opensubtitles.org's folks for their great service.
    Copyright 2013 Bence Romsics <rubasov@gmail.com>

TODO
    functional
        better handling of search results
            nice error message if subtitle not found
                hint on embedded subtitle streams
                link to manual search
            select 2nd, 3rd, etc.
        parameters
            --template -
                stdout
            --print-hash
            --language lang1,lang2,...
                preference order
                validate language id
            --template-num-start, default=1
        overwrite
            refuse to do it by default
            do it if asked explicitly
        upload to github
            ask for review by opensubtitles' folks
        documentation
        license
        rename to opensub-get ?
    development practice
        python2/3 compatibility
        unix/windows portability
        setup.py
        unit test suite
            if __name__ == "__main__": test()
"""

import argparse
import errno
import logging
import os
import sys

sys.path.append(
     os.path.join(
         os.path.dirname(__file__), "..", "lib" ) )

import opensubtitles

def setup_logging(verbosity):

    """
    Set log level and format.
    """

    log_level_dict = {
        0: "WARNING",
        1: "INFO",
        2: "DEBUG",
        }

    try:
        log_level = getattr( logging, log_level_dict[verbosity] )
    except KeyError:
        raise Exception(
            "invalid log level: -{}".format( "v" * verbosity ) )

    logging.basicConfig(
        level = log_level,
        format = "%(levelname)s: %(filename)s:%(lineno)d: %(message)s",
        )

    return None

def parse_cli_args():

    """
    Procedure for command line argument parsing.
    """

    p = argparse.ArgumentParser()

    p.add_argument(
        "-l", "--language",
        action = "store",
        default = "eng",
        help = "subtitle language id (ISO 639), default: eng",
        )

    p.add_argument(
        "-s", "--server",
        action = "store",
        default = "www.opensubtitles.org",
        help = "server to query, default: www.opensubtitles.org",
        )

    p.add_argument(
        "-t", "--template",
        action = "store",
        help = "name output files like: 'template-{num}.{ext}', optional",
        )

    p.add_argument(
        "-v", "--verbose",
        action = "count",
        default = 0,
        help = "increase verbosity (-v, -vv), optional",
        )

    p.add_argument(
        "-x", "--extract",
        action = "store_true",
        default = False,
        help = "extract subtitles as named in the archive, optional",
        )

    p.add_argument("movie",
        nargs = "+",
        help = "video file (or files belonging to the same movie)",
        )

    return p.parse_args()

def main():

    args = parse_cli_args()
    setup_logging( verbosity = args.verbose )

    for video_file in args.movie:
        if not os.path.isfile(video_file):
            raise Exception( "no such file: {}".format(video_file) )

    def user_agent(
        program = os.path.basename( sys.argv[0] ),
        version = "0.9",
        ):
        return "{}/{}".format(program, version)

    ua = opensubtitles.UserAgent(
        server = args.server,
        user_agent = user_agent(),
        )

    subtitle_list = ua.get_subtitle(
        movie = args.movie,
        language = args.language,
        )

    # name output files according to --template
    if not args.template is None:

        for idx, subtitle in enumerate(subtitle_list, start=1):
            _, ext = os.path.splitext(subtitle.name)
            assert ext != ""
            path = args.template.format(num=idx, ext=ext[1:])
            logging.debug("sub_path: {}".format(path))
            subtitle.write(path=path)

    # name output files as they were named in the archive
    # ignore directories in the archive
    elif args.extract:

        for subtitle in subtitle_list:
            path = os.path.basename(subtitle.name)
            logging.debug("sub_path: {}".format(path))
            try:
                subtitle.write_no_overwrite(path=path)
            except OSError as e:
                if e.errno == errno.EEXIST:
                    logging.debug(
                        "cowardly refusing to overwrite file: {}".format(path))
                    pass
                else:
                    raise

    # name output files to match video file names
    # but with different extension: foo.avi -> foo.srt
    else:

        # assumptions:
        #   * the user provided video files in "natural order"
        #   * subtitle_list is sorted by subtitle.name,
        #     therefore it is in "natural order"
        for video_file, subtitle in zip( args.movie, subtitle_list ):

            assert not video_file is None
            assert not subtitle is None

            base, _ = os.path.splitext(video_file)
            _, extension = os.path.splitext(subtitle.name)
            path = base + extension

            logging.debug(
                "sub_path: {}".format(path) )

            # FIXME duplicate code
            try:
                subtitle.write_no_overwrite(path=path)
            except OSError as e:
                if e.errno == errno.EEXIST:
                    logging.debug(
                        "cowardly refusing to overwrite file: {}".format(path))
                    pass
                else:
                    raise

if __name__ == "__main__":
    main()
